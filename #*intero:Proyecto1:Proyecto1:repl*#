Starting:
  stack ghci --with-ghc ghci --docker-run-args=--interactive=true --no-build --no-load Proyecto1
GHCi, version 8.8.3: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/daniel/.ghci
Loaded GHCi configuration from /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/.stack-work/intero/intero-scriptzmSZuY
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:122:11: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the expression: [(toEnum $ fromEnum minBound :: Carta) .. ]
      In an equation for ‘baraja’:
          baraja = [(toEnum $ fromEnum minBound :: Carta) .. ]
    |
122 | baraja =  [(toEnum $ fromEnum minBound::Carta) .. ]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:122:11: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the expression: [minBound :: Carta .. ]
      In an equation for ‘baraja’: baraja = [minBound :: Carta .. ]
    |
122 | baraja =  [minBound::Carta .. ]
    |           ^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:122:11: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the expression: [(minBound :: Carta) .. ]
      In an equation for ‘baraja’: baraja = [(minBound :: Carta) .. ]
    |
122 | baraja =  [(minBound::Carta) .. ]
    |           ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 minBound::Carta
੩A
 [minBound::Carta]
[੩A]
 [minBound::Carta .. ]
[*** Exception: toEnum{Palo}: tag (10) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 take 5 [minBound::Carta .. ]
[*** Exception: toEnum{Palo}: tag (10) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 take 1 [minBound::Carta .. ]
[*** Exception: toEnum{Palo}: tag (10) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 toEnum 10
*** Exception: Prelude.Enum.().toEnum: bad argument
 toEnum 10::Carta
੤10
 [1..52]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]
 fmap (toEnum::Carta )[1..52]

<interactive>:98:7: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Int -> a0’
    • Probable cause: ‘toEnum’ is applied to too few arguments
      In the first argument of ‘fmap’, namely ‘(toEnum :: Carta)’
      In the expression: fmap (toEnum :: Carta) [1 .. 52]
      In an equation for ‘it’: it = fmap (toEnum :: Carta) [1 .. 52]

<interactive>:98:7: error:
    • Couldn't match expected type ‘Integer -> b’
                  with actual type ‘Carta’
    • In the first argument of ‘fmap’, namely ‘(toEnum :: Carta)’
      In the expression: fmap (toEnum :: Carta) [1 .. 52]
      In an equation for ‘it’: it = fmap (toEnum :: Carta) [1 .. 52]
    • Relevant bindings include it :: [b] (bound at <interactive>:98:1)
 fmap (toEnum )[1..52]
[*** Exception: Prelude.Enum.().toEnum: bad argument
 fmap (toEnum)[1::Carta..52::Carta]
[(minBound::Carta) .. ]
<interactive>:120:18: error:
    Operator applied to too few arguments: Carta..
 fmap (toEnum)[(1::Carta)..(52::Carta)]

<interactive>:123:16: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Carta’
    • In the expression: (1 :: Carta)
      In the second argument of ‘fmap’, namely
        ‘[(1 :: Carta) .. (52 :: Carta)]’
      In the expression: fmap (toEnum) [(1 :: Carta) .. (52 :: Carta)]

<interactive>:123:28: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Carta’
    • In the expression: (52 :: Carta)
      In the second argument of ‘fmap’, namely
        ‘[(1 :: Carta) .. (52 :: Carta)]’
      In the expression: fmap (toEnum) [(1 :: Carta) .. (52 :: Carta)]
 fmap toEnum [1..52]
[*** Exception: Prelude.Enum.().toEnum: bad argument
 fmap toEnum::Carta [1..52]

<interactive>:148:22: error: parse error on input ‘..’
 fmap toEnum::Carta [1 .. 52]

<interactive>:151:23: error: parse error on input ‘..’
 fmap toEnum::Carta $ [1 .. 52]

<interactive>:154:25: error: parse error on input ‘..’
 fmap (toEnum::Carta) $ [1 .. 52]

<interactive>:156:7: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Int -> a0’
    • Probable cause: ‘toEnum’ is applied to too few arguments
      In the first argument of ‘fmap’, namely ‘(toEnum :: Carta)’
      In the expression: fmap (toEnum :: Carta)
      In the expression: fmap (toEnum :: Carta) $ [1 .. 52]

<interactive>:156:7: error:
    • Couldn't match expected type ‘Integer -> b’
                  with actual type ‘Carta’
    • In the first argument of ‘fmap’, namely ‘(toEnum :: Carta)’
      In the expression: fmap (toEnum :: Carta)
      In the expression: fmap (toEnum :: Carta) $ [1 .. 52]
    • Relevant bindings include
        it :: [b] (bound at <interactive>:156:1)
 fmap (toEnum::Integer->Carta) $ [1 .. 52]

<interactive>:166:7: error:
    • Couldn't match type ‘Integer’ with ‘Int’
      Expected type: Integer -> Carta
        Actual type: Int -> Carta
    • In the first argument of ‘fmap’, namely
        ‘(toEnum :: Integer -> Carta)’
      In the expression: fmap (toEnum :: Integer -> Carta)
      In the expression: fmap (toEnum :: Integer -> Carta) $ [1 .. 52]
 fmap (toEnum::Int->Carta) $ [1 .. 52]
[੧A,੧2,੧3,੪4,੪5,੪6,੪7,੤8,੤9,੤10,੤J,੩Q,੩K,੩A,੩2,*** Exception: toEnum{Palo}: tag (4) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 fmap (toEnum::Int->Carta) $ [1 .. 52]
[*** Exception: toEnum{Palo}: tag (-1) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 fmap (toEnum::Int->Carta) $ [1 .. 52]
[੧A,੧2,੧3,੪4,੪5,੪6,੪7,੤8,੤9,੤10,੤J,੩Q,੩K,੩A,੩2,*** Exception: toEnum{Palo}: tag (4) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 fmap (toEnum::Int->Carta) $ [1 .. 52]
[੧A,੧2,੧3,੧4,੧5,੧6,੧7,੧8,੧9,੧10,੧J,੧Q,੪K,੪A,੪2,੪3,੪4,੪5,੪6,੪7,੪8,੪9,੪10,੪J,੪Q,੤K,੤A,੤2,੤3,੤4,੤5,੤6,੤7,੤8,੤9,੤10,੤J,੤Q,੩K,੩A,੩2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,*** Exception: toEnum{Palo}: tag (4) is outside of enumeration's range (0,3)
CallStack (from HasCallStack):
  error, called at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:14:66 in main:DataTypes
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 
Ok, one module loaded.

 fmap (toEnum::Int->Carta) $ [1 .. 52]
[੧A,੧2,੧3,੧4,੧5,੧6,੧7,੧8,੧9,੧10,੧J,੧Q,੧K,੪A,੪2,੪3,੪4,੪5,੪6,੪7,੪8,੪9,੪10,੪J,੪Q,੪K,੪A,੤2,੤3,੤4,੤5,੤6,੤7,੤8,੤9,੤10,੤J,੤Q,੤K,੤A,੤2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 [minBound::Carta ..]
[੤A,੤2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:97:94: error:
    • No instance for (Fractional Int) arising from the literal ‘0.1’
    • In the second argument of ‘(-)’, namely ‘0.1’
      In the first argument of ‘div’, namely ‘(x - 0.1)’
      In the second argument of ‘($)’, namely ‘(x - 0.1) `div` 13’
   |
97 |   toEnum x | 1<= x && x<= 52 = Carta {rango = toEnum $ (x-1) `mod` 13 + 1,palo = toEnum $ (x-0.1) `div` 13}
   |                                                                                              ^^^
Failed, no modules loaded.

 :t div
$"
"Prelude.$!"
"Prelude.&&"
"Prelude.*"div
"Prelude.**"
"Prelude.*>"
"Prelude.+"
"Prelude.++"
"Prelude.-"
"Prelude.."
"Prelude./"
"Prelude./="
"Prelude.<"
"Prelude.<$"
"Prelude.<$>"
"Prelude.<*"
"Prelude.<*>"
"Prelude.<="
"Prelude.<>"
"Prelude.=<<"
"Prelude.=="
"Prelude.>"
"Prelude.>="
"Prelude.>>"
"Prelude.>>="
"Prelude.Applicative"
"Prelude.Bool"
"Prelude.Bounded"
"Prelude.Char"
"Prelude.Double"
"Prelude.EQ"
"Prelude.Either"
"Prelude.Enum"
"Prelude.Eq"
"Prelude.False"
"Prelude.FilePath"
"Prelude.Float"
"Prelude.Floating"
"Prelude.Foldable"
"Prelude.Fractional"
"Prelude.Functor"
"Prelude.GT"
"Prelude.IO"
"Prelude.IOError"
"Prelude.Int"
"Prelude.Integer"
"Prelude.Integral"
"Prelude.Just"
"Prelude.LT"
"Prelude.Left"
"Prelude.Maybe"
"Prelude.Monad"
"Prelude.MonadFail"
"Prelude.Monoid"
"Prelude.Nothing"
"Prelude.Num"
"Prelude.Ord"
"Prelude.Ordering"
"Prelude.Rational"
"Prelude.Read"
"Prelude.ReadS"
"Prelude.Real"
"Prelude.RealFloat"
"Prelude.RealFrac"
"Prelude.Right"
"Prelude.Semigroup"
"Prelude.Show"
"Prelude.ShowS"
"Prelude.String"
"Prelude.Traversable"
"Prelude.True"
"Prelude.Word"
"Prelude.^"
"Prelude.^^"
"Prelude.abs"
"Prelude.acos"
"Prelude.acosh"
"Prelude.all"
"Prelude.and"
"Prelude.any"
"Prelude.appendFile"
"Prelude.asTypeOf"
"Prelude.asin"
"Prelude.asinh"
"Prelude.atan"
"Prelude.atan2"
"Prelude.atanh"
"Prelude.break"
"Prelude.ceiling"
"Prelude.compare"
"Prelude.concat"
"Prelude.concatMap"
"Prelude.const"
"Prelude.cos"
"Prelude.cosh"
"Prelude.curry"
"Prelude.cycle"
"Prelude.decodeFloat"
"Prelude.div"
"Prelude.divMod"
"Prelude.drop"
"Prelude.dropWhile"
"Prelude.either"
"Prelude.elem"
"Prelude.encodeFloat"
"Prelude.enumFrom"
"Prelude.enumFromThen"
"Prelude.enumFromThenTo"
"Prelude.enumFromTo"
"Prelude.error"
"Prelude.errorWithoutStackTrace"
"Prelude.even"
"Prelude.exp"
"Prelude.exponent"
"Prelude.fail"
"Prelude.filter"
"Prelude.flip"
"Prelude.floatDigits"
"Prelude.floatRadix"
"Prelude.floatRange"
"Prelude.floor"
"Prelude.fmap"
"Prelude.foldMap"
"Prelude.foldl"
"Prelude.foldl1"
"Prelude.foldr"
"Prelude.foldr1"
"Prelude.fromEnum"
"Prelude.fromInteger"
"Prelude.fromIntegral"
"Prelude.fromRational"
"Prelude.fst"
"Prelude.gcd"
"Prelude.getChar"
"Prelude.getContents"
"Prelude.getLine"
"Prelude.head"
"Prelude.id"
"Prelude.init"
"Prelude.interact"
"Prelude.ioError"
"Prelude.isDenormalized"
"Prelude.isIEEE"
"Prelude.isInfinite"
"Prelude.isNaN"
"Prelude.isNegativeZero"
"Prelude.iterate"
"Prelude.last"
"Prelude.lcm"
"Prelude.length"
"Prelude.lex"
"Prelude.lines"
"Prelude.log"
"Prelude.logBase"
"Prelude.lookup"
"Prelude.map"
"Prelude.mapM"
"Prelude.mapM_"
"Prelude.mappend"
"Prelude.max"
"Prelude.maxBound"
"Prelude.maximum"
"Prelude.maybe"
"Prelude.mconcat"
"Prelude.mempty"
"Prelude.min"
"Prelude.minBound"
"Prelude.minimum"
"Prelude.mod"
"Prelude.negate"
"Prelude.not"
"Prelude.notElem"
"Prelude.null"
"Prelude.odd"
"Prelude.or"
"Prelude.otherwise"
"Prelude.pi"
"Prelude.pred"
"Prelude.print"
"Prelude.product"
"Prelude.properFraction"
"Prelude.pure"
"Prelude.putChar"
"Prelude.putStr"
"Prelude.putStrLn"
"Prelude.quot"
"Prelude.quotRem"
"Prelude.read"
"Prelude.readFile"
"Prelude.readIO"
"Prelude.readList"
"Prelude.readLn"
"Prelude.readParen"
"Prelude.reads"
"Prelude.readsPrec"
"Prelude.realToFrac"
"Prelude.recip"
"Prelude.rem"
"Prelude.repeat"
"Prelude.replicate"
"Prelude.return"
"Prelude.reverse"
"Prelude.round"
"Prelude.scaleFloat"
"Prelude.scanl"
"Prelude.scanl1"
"Prelude.scanr"
"Prelude.scanr1"
"Prelude.seq"
"Prelude.sequence"
"Prelude.sequenceA"
"Prelude.sequence_"
"Prelude.show"
"Prelude.showChar"
"Prelude.showList"
"Prelude.showParen"
"Prelude.showString"
"Prelude.shows"
"Prelude.showsPrec"
"Prelude.significand"
"Prelude.signum"
"Prelude.sin"
"Prelude.sinh"
"Prelude.snd"
"Prelude.span"
"Prelude.splitAt"
"Prelude.sqrt"
"Prelude.subtract"
"Prelude.succ"
"Prelude.sum"
"Prelude.tail"
"Prelude.take"
"Prelude.takeWhile"
"Prelude.tan"
"Prelude.tanh"
"Prelude.toEnum"
"Prelude.toInteger"
"Prelude.toRational"
"Prelude.traverse"
"Prelude.truncate"
"Prelude.uncurry"
"Prelude.undefined"
"Prelude.unlines"
"Prelude.until"
"Prelude.unwords"
"Prelude.unzip"
"Prelude.unzip3"
"Prelude.userError"
"Prelude.words"
"Prelude.writeFile"
"Prelude.zip"
"Prelude.zip3"
"Prelude.zipWith"
"Prelude.zipWith3"
"Prelude.||"
"Rational"
"Read"
"ReadS"
"Real"
"RealFloat"
"RealFrac"
"Right"
"Semigroup"
"Show"
"ShowS"
"String"
"Traversable"
"True"
"Word"
"^"
"^^"
"abs"
"acos"
"acosh"
"all"
"and"
"any"
"appendFile"
"asTypeOf"
"asin"
"asinh"
"atan"
"atan2"
"atanh"
"break"
"ceiling"
"compare"
"concat"
"concatMap"
"const"
"cos"
"cosh"
"curry"
"cycle"
"decodeFloat"
"div"
"divMod"
"drop"
"dropWhile"
"either"
"elem"
"encodeFloat"
"enumFrom"
"enumFromThen"
"enumFromThenTo"
"enumFromTo"
"error"
"errorWithoutStackTrace"
"even"
"exp"
"exponent"
"fail"
"filter"
"flip"
"floatDigits"
"floatRadix"
"floatRange"
"floor"
"fmap"
"foldMap"
"foldl"
"foldl1"
"foldr"
"foldr1"
"fromEnum"
"fromInteger"
"fromIntegral"
"fromRational"
"fst"
"gcd"
"getChar"
"getContents"
"getLine"
"head"
"id"
"init"
"interact"
"ioError"
"isDenormalized"
"isIEEE"
"isInfinite"
"isNaN"
"isNegativeZero"
"iterate"
"last"
"lcm"
"length"
"lex"
"lines"
"log"
"logBase"
"lookup"
"map"
"mapM"
"mapM_"
"mappend"
"max"
"maxBound"
"maximum"
"maybe"
"mconcat"
"mempty"
"min"
"minBound"
"minimum"
"mod"
"negate"
"not"
"notElem"
"null"
"odd"
"or"
"otherwise"
"pi"
"pred"
"print"
"product"
"properFraction"
"pure"
"putChar"
"putStr"
"putStrLn"
"quot"
"quotRem"
"read"
"readFile"
"readIO"
"readList"
"readLn"
"readParen"
"reads"
"readsPrec"
"realToFrac"
"recip"
"rem"
"repeat"
"replicate"
"return"
"reverse"
"round"
"scaleFloat"
"scanl"
"scanl1"
"scanr"
"scanr1"
"seq"
"sequence"
"sequenceA"
"sequence_"
"show"
"showChar"
"showList"
"showParen"
"showString"
"shows"
"showsPrec"
"significand"
"signum"
"sin"
"sinh"
"snd"
"span"
"splitAt"
"sqrt"
"subtract"
"succ"
"sum"
"tail"
"take"
"takeWhile"
"tan"
"tanh"
"toEnum"
"toInteger"
"toRational"
"traverse"
"truncate"
"uncurry"
"undefined"
"unlines"
"until"
"unwords"
"unzip"
"unzip3"
"userError"
"words"
"writeFile"
"zip"
"zip3"
"zipWith"
"zipWith3"
"||"
 :t div
relude.++"
"Prelude.-"
"Prelude.."
"Prelude./"
"Prelude./="
"Prelude.<"
"Prelude.<$"
"Prelude.<$>"
"Prelude.<*"
"Prelude.<*>"
"Prelude.<="
"Prelude.<>"
"Prelude.=<<"
"Prelude.=="
"Prelude.>"
"Prelude.>="
"Prelude.>>"
"Prelude.>>="
"Prelude.Applicative"
"Prelude.Bool"
"Prelude.Bounded"
"Prelude.Char"
"Prelude.Double"
"Prelude.EQ"
"Prelude.Either"
"Prelude.Enum"
"Prelude.Eq"
"Prelude.False"
"Prelude.FilePath"
"Prelude.Float"
"Prelude.Floating"
"Prelude.Foldable"
"Prelude.Fractional"
"Prelude.Functor"
"Prelude.GT"
"Prelude.IO"
"Prelude.IOError"
"Prelude.Int"
"Prelude.Integer"
"Prelude.Integral"
"Prelude.Just"
"Prelude.LT"
"Prelude.Left"
"Prelude.Maybe"
"Prelude.Monad"
"Prelude.MonadFail"
"Prelude.Monoid"
"Prelude.Nothing"
"Prelude.Num"
"Prelude.Ord"
"Prelude.Ordering"
"Prelude.Rational"
"Prelude.Read"
"Prelude.ReadS"
"Prelude.Real"
"Prelude.RealFloat"
"Prelude.RealFrac"
"Prelude.Right"
"Prelude.Semigroup"
"Prelude.Show"
"Prelude.ShowS"
"Prelude.String"
"Prelude.Traversable"
"Prelude.True"
"Prelude.Word"
"Prelude.^"
"Prelude.^^"
"Prelude.abs"
"Prelude.acos"
"Prelude.acosh"
"Prelude.all"
"Prelude.and"
"Prelude.any"
"Prelude.appendFile"
"Prelude.asTypeOf"
"Prelude.asin"
"Prelude.asinh"
"Prelude.atan"
"Prelude.atan2"
"Prelude.atanh"
"Prelude.break"
"Prelude.ceiling"
"Prelude.compare"
"Prelude.concat"
"Prelude.concatMap"
"Prelude.const"
"Prelude.cos"
"Prelude.cosh"
"Prelude.curry"
"Prelude.cycle"
"Prelude.decodeFloat"
"Prelude.div"
"Prelude.divMod"
"Prelude.drop"
"Prelude.dropWhile"
"Prelude.either"
"Prelude.elem"
"Prelude.encodeFloat"
"Prelude.enumFrom"
"Prelude.enumFromThen"
"Prelude.enumFromThenTo"
"Prelude.enumFromTo"
"Prelude.error"
"Prelude.errorWithoutStackTrace"
"Prelude.even"
"Prelude.exp"
"Prelude.exponent"
"Prelude.fail"
"Prelude.filter"
"Prelude.flip"
"Prelude.floatDigits"
"Prelude.floatRadix"
"Prelude.floatRange"
"Prelude.floor"
"Prelude.fmap"
"Prelude.foldMap"
"Prelude.foldl"
"Prelude.foldl1"
"Prelude.foldr"
"Prelude.foldr1"
"Prelude.fromEnum"
"Prelude.fromInteger"
"Prelude.fromIntegral"
"Prelude.fromRational"
"Prelude.fst"
"Prelude.gcd"
"Prelude.getChar"
"Prelude.getContents"
"Prelude.getLine"
"Prelude.head"
"Prelude.id"
"Prelude.init"
"Prelude.interact"
"Prelude.ioError"
"Prelude.isDenormalized"
"Prelude.isIEEE"
"Prelude.isInfinite"
"Prelude.isNaN"
"Prelude.isNegativeZero"
"Prelude.iterate"
"Prelude.last"
"Prelude.lcm"
"Prelude.length"
"Prelude.lex"
"Prelude.lines"
"Prelude.log"
"Prelude.logBase"
"Prelude.lookup"
"Prelude.map"
"Prelude.mapM"
"Prelude.mapM_"
"Prelude.mappend"
"Prelude.max"
"Prelude.maxBound"
"Prelude.maximum"
"Prelude.maybe"
"Prelude.mconcat"
"Prelude.mempty"
"Prelude.min"
"Prelude.minBound"
"Prelude.minimum"
"Prelude.mod"
"Prelude.negate"
"Prelude.not"
"Prelude.notElem"
"Prelude.null"
"Prelude.odd"
"Prelude.or"
"Prelude.otherwise"
"Prelude.pi"
"Prelude.pred"
"Prelude.print"
"Prelude.product"
"Prelude.properFraction"
"Prelude.pure"
"Prelude.putChar"
"Prelude.putStr"
"Prelude.putStrLn"
"Prelude.quot"
"Prelude.quotRem"
"Prelude.read"
"Prelude.readFile"
"Prelude.readIO"
"Prelude.readList"
"Prelude.readLn"
"Prelude.readParen"
"Prelude.reads"
"Prelude.readsPrec"
"Prelude.realToFrac"
"Prelude.recip"
"Prelude.rem"
"Prelude.repeat"
"Prelude.replicate"
"Prelude.return"
"Prelude.reverse"
"Prelude.round"
"Prelude.scaleFloat"
"Prelude.scanl"
"Prelude.scanl1"
"Prelude.scanr"
"Prelude.scanr1"
"Prelude.seq"
"Prelude.sequence"
"Prelude.sequenceA"
"Prelude.sequence_"
"Prelude.show"
"Prelude.showChar"
"Prelude.showList"
"Prelude.showParen"
"Prelude.showString"
"Prelude.shows"
"Prelude.showsPrec"
"Prelude.significand"
"Prelude.signum"
"Prelude.sin"
"Prelude.sinh"
"Prelude.snd"
"Prelude.span"
"Prelude.splitAt"
"Prelude.sqrt"
"Prelude.subtract"
"Prelude.succ"
"Prelude.sum"
"Prelude.tail"
"Prelude.take"
"Prelude.takeWhile"
"Prelude.tan"
"Prelude.tanh"
"Prelude.toEnum"
"Prelude.toInteger"
"Prelude.toRational"
"Prelude.traverse"
"Prelude.truncate"
"Prelude.uncurry"
"Prelude.undefined"
"Prelude.unlines"
"Prelude.until"
"Prelude.unwords"
"Prelude.unzip"
"Prelude.unzip3"
"Prelude.userError"
"Prelude.words"
"Prelude.writeFile"
"Prelude.zip"
"Prelude.zip3"
"Prelude.zipWith"
"Prelude.zipWith3"
"Prelude.||"
"Rational"
"Read"
"ReadS"
"Real"
"RealFloat"
"RealFrac"
"Right"
"Semigroup"
"Show"
"ShowS"
"String"
"Traversable"
"True"
"Word"
"^"
"^^"
"abs"
"acos"
"acosh"
"all"
"and"
"any"
"appendFile"
"asTypeOf"
"asin"
"asinh"
"atan"
"atan2"
"atanh"
"break"
"ceiling"
"compare"
"concat"
"concatMap"
"const"
"cos"
"cosh"
"curry"
"cycle"
"decodeFloat"
"div"
"divMod"
"drop"
"dropWhile"
"either"
"elem"
"encodeFloat"
"enumFrom"
"enumFromThen"
"enumFromThenTo"
"enumFromTo"
"error"
"errorWithoutStackTrace"
"even"
"exp"
"exponent"
"fail"
"filter"
"flip"
"floatDigits"
"floatRadix"
"floatRange"
"floor"
"fmap"
"foldMap"
"foldl"
"foldl1"
"foldr"
"foldr1"
"fromEnum"
"fromInteger"
"fromIntegral"
"fromRational"
"fst"
"gcd"
"getChar"
"getContents"
"getLine"
"head"
"id"
"init"
"interact"
"ioError"
"isDenormalized"
"isIEEE"
"isInfinite"
"isNaN"
"isNegativeZero"
"iterate"
"last"
"lcm"
"length"
"lex"
"lines"
"log"
"logBase"
"lookup"
"map"
"mapM"
"mapM_"
"mappend"
"max"
"maxBound"
"maximum"
"maybe"
"mconcat"
"mempty"
"min"
"minBound"
"minimum"
"mod"
"negate"
"not"
"notElem"
"null"
"odd"
"or"
"otherwise"
"pi"
"pred"
"print"
"product"
"properFraction"
"pure"
"putChar"
"putStr"
"putStrLn"
"quot"
"quotRem"
"read"
"readFile"
"readIO"
"readList"
"readLn"
"readParen"
"reads"
"readsPrec"
"realToFrac"
"recip"
"rem"
"repeat"
"replicate"
"return"
"reverse"
"round"
"scaleFloat"
"scanl"
"scanl1"
"scanr"
"scanr1"
"seq"
"sequence"
"sequenceA"
"sequence_"
"show"
"showChar"
"showList"
"showParen"
"showString"
"shows"
"showsPrec"
"significand"
"signum"
"sin"
"sinh"
"snd"
"span"
"splitAt"
"sqrt"
"subtract"
"succ"
"sum"
"tail"
"take"
"takeWhile"
"tan"
"tanh"
"toEnum"
"toInteger"
"toRational"
"traverse"
"truncate"
"uncurry"
"undefined"
"unlines"
"until"
"unwords"
"unzip"
"unzip3"
"userError"
"words"
"writeFile"
"zip"
"zip3"
"zipWith"
"zipWith3"
"||"
 "Prelude.*"div
"Prelude.**"
"Prelude.*>"
"Prelude.+"
"Prelude.++"
"Prelude.-"
"Prelude.."
"Prelude./"
"Prelude./="
"Prelude.<"
"Prelude.<$"
"Prelude.<$>"
"Prelude.<*"
"Prelude.<*>"
"Prelude.<="
"Prelude.<>"
"Prelude.=<<"
"Prelude.=="
"Prelude.>"
"Prelude.>="
"Prelude.>>"
"Prelude.>>="
"Prelude.Applicative"
"Prelude.Bool"
"Prelude.Bounded"
"Prelude.Char"
"Prelude.Double"
"Prelude.EQ"
"Prelude.Either"
"Prelude.Enum"
"Prelude.Eq"
"Prelude.False"
"Prelude.FilePath"
"Prelude.Float"
"Prelude.Floating"
"Prelude.Foldable"
"Prelude.Fractional"
"Prelude.Functor"
"Prelude.GT"
"Prelude.IO"
"Prelude.IOError"
"Prelude.Int"
"Prelude.Integer"
"Prelude.Integral"
"Prelude.Just"
"Prelude.LT"
"Prelude.Left"
"Prelude.Maybe"
"Prelude.Monad"
"Prelude.MonadFail"
"Prelude.Monoid"
"Prelude.Nothing"
"Prelude.Num"
"Prelude.Ord"
"Prelude.Ordering"
"Prelude.Rational"
"Prelude.Read"
"Prelude.ReadS"
"Prelude.Real"
"Prelude.RealFloat"
"Prelude.RealFrac"
"Prelude.Right"
"Prelude.Semigroup"
"Prelude.Show"
"Prelude.ShowS"
"Prelude.String"
"Prelude.Traversable"
"Prelude.True"
"Prelude.Word"
"Prelude.^"
"Prelude.^^"
"Prelude.abs"
"Prelude.acos"
"Prelude.acosh"
"Prelude.all"
"Prelude.and"
"Prelude.any"
"Prelude.appendFile"
"Prelude.asTypeOf"
"Prelude.asin"
"Prelude.asinh"
"Prelude.atan"
"Prelude.atan2"
"Prelude.atanh"
"Prelude.break"
"Prelude.ceiling"
"Prelude.compare"
"Prelude.concat"
"Prelude.concatMap"
"Prelude.const"
"Prelude.cos"
"Prelude.cosh"
"Prelude.curry"
"Prelude.cycle"
"Prelude.decodeFloat"
"Prelude.div"
"Prelude.divMod"
"Prelude.drop"
"Prelude.dropWhile"
"Prelude.either"
"Prelude.elem"
"Prelude.encodeFloat"
"Prelude.enumFrom"
"Prelude.enumFromThen"
"Prelude.enumFromThenTo"
"Prelude.enumFromTo"
"Prelude.error"
"Prelude.errorWithoutStackTrace"
"Prelude.even"
"Prelude.exp"
"Prelude.exponent"
"Prelude.fail"
"Prelude.filter"
"Prelude.flip"
"Prelude.floatDigits"
"Prelude.floatRadix"
"Prelude.floatRange"
"Prelude.floor"
"Prelude.fmap"
"Prelude.foldMap"
"Prelude.foldl"
"Prelude.foldl1"
"Prelude.foldr"
"Prelude.foldr1"
"Prelude.fromEnum"
"Prelude.fromInteger"
"Prelude.fromIntegral"
"Prelude.fromRational"
"Prelude.fst"
"Prelude.gcd"
"Prelude.getChar"
"Prelude.getContents"
"Prelude.getLine"
"Prelude.head"
"Prelude.id"
"Prelude.init"
"Prelude.interact"
"Prelude.ioError"
"Prelude.isDenormalized"
"Prelude.isIEEE"
"Prelude.isInfinite"
"Prelude.isNaN"
"Prelude.isNegativeZero"
"Prelude.iterate"
"Prelude.last"
"Prelude.lcm"
"Prelude.length"
"Prelude.lex"
"Prelude.lines"
"Prelude.log"
"Prelude.logBase"
"Prelude.lookup"
"Prelude.map"
"Prelude.mapM"
"Prelude.mapM_"
"Prelude.mappend"
"Prelude.max"
"Prelude.maxBound"
"Prelude.maximum"
"Prelude.maybe"
"Prelude.mconcat"
"Prelude.mempty"
"Prelude.min"
"Prelude.minBound"
"Prelude.minimum"
"Prelude.mod"
"Prelude.negate"
"Prelude.not"
"Prelude.notElem"
"Prelude.null"
"Prelude.odd"
"Prelude.or"
"Prelude.otherwise"
"Prelude.pi"
"Prelude.pred"
"Prelude.print"
"Prelude.product"
"Prelude.properFraction"
"Prelude.pure"
"Prelude.putChar"
"Prelude.putStr"
"Prelude.putStrLn"
"Prelude.quot"
"Prelude.quotRem"
"Prelude.read"
"Prelude.readFile"
"Prelude.readIO"
"Prelude.readList"
"Prelude.readLn"
"Prelude.readParen"
"Prelude.reads"
"Prelude.readsPrec"
"Prelude.realToFrac"
"Prelude.recip"
"Prelude.rem"
"Prelude.repeat"
"Prelude.replicate"
"Prelude.return"
"Prelude.reverse"
"Prelude.round"
"Prelude.scaleFloat"
"Prelude.scanl"
"Prelude.scanl1"
"Prelude.scanr"
"Prelude.scanr1"
"Prelude.seq"
"Prelude.sequence"
"Prelude.sequenceA"
"Prelude.sequence_"
"Prelude.show"
"Prelude.showChar"
"Prelude.showList"
"Prelude.showParen"
"Prelude.showString"
"Prelude.shows"
"Prelude.showsPrec"
"Prelude.significand"
"Prelude.signum"
"Prelude.sin"
"Prelude.sinh"
"Prelude.snd"
"Prelude.span"
"Prelude.splitAt"
"Prelude.sqrt"
"Prelude.subtract"
"Prelude.succ"
"Prelude.sum"
"Prelude.tail"
"Prelude.take"
"Prelude.takeWhile"
"Prelude.tan"
"Prelude.tanh"
"Prelude.toEnum"
"Prelude.toInteger"
"Prelude.toRational"
"Prelude.traverse"
"Prelude.truncate"
"Prelude.uncurry"
"Prelude.undefined"
"Prelude.unlines"
"Prelude.until"
"Prelude.unwords"
"Prelude.unzip"
"Prelude.unzip3"
"Prelude.userError"
"Prelude.words"
"Prelude.writeFile"
"Prelude.zip"
"Prelude.zip3"
"Prelude.zipWith"
"Prelude.zipWith3"
"Prelude.||"
"Rational"
"Read"
"ReadS"
"Real"
"RealFloat"
"RealFrac"
"Right"
"Semigroup"
"Show"
"ShowS"
"String"
"Traversable"
"True"
"Word"
"^"
"^^"
"abs"
"acos"
"acosh"
"all"
"and"
"any"
"appendFile"
"asTypeOf"
"asin"
"asinh"
"atan"
"atan2"
"atanh"
"break"
"ceiling"
"compare"
"concat"
"concatMap"
"const"
"cos"
"cosh"
"curry"
"cycle"
"decodeFloat"
"div"
"divMod"
"drop"
"dropWhile"
"either"
"elem"
"encodeFloat"
"enumFrom"
"enumFromThen"
"enumFromThenTo"
"enumFromTo"
"error"
"errorWithoutStackTrace"
"even"
"exp"
"exponent"
"fail"
"filter"
"flip"
"floatDigits"
"floatRadix"
"floatRange"
"floor"
"fmap"
"foldMap"
"foldl"
"foldl1"
"foldr"
"foldr1"
"fromEnum"
"fromInteger"
"fromIntegral"
"fromRational"
"fst"
"gcd"
"getChar"
"getContents"
"getLine"
"head"
"id"
"init"
"interact"
"ioError"
"isDenormalized"
"isIEEE"
"isInfinite"
"isNaN"
"isNegativeZero"
"iterate"
"last"
"lcm"
"length"
"lex"
"lines"
"log"
"logBase"
"lookup"
"map"
"mapM"
"mapM_"
"mappend"
"max"
"maxBound"
"maximum"
"maybe"
"mconcat"
"mempty"
"min"
"minBound"
"minimum"
"mod"
"negate"
"not"
"notElem"
"null"
"odd"
"or"
"otherwise"
"pi"
"pred"
"print"
"product"
"properFraction"
"pure"
"putChar"
"putStr"
"putStrLn"
"quot"
"quotRem"
"read"
"readFile"
"readIO"
"readList"
"readLn"
"readParen"
"reads"
"readsPrec"
"realToFrac"
"recip"
"rem"
"repeat"
"replicate"
"return"
"reverse"
"round"
"scaleFloat"
"scanl"
"scanl1"
"scanr"
"scanr1"
"seq"
"sequence"
"sequenceA"
"sequence_"
"show"
"showChar"
"showList"
"showParen"
"showString"
"shows"
"showsPrec"
"significand"
"signum"
"sin"
"sinh"
"snd"
"span"
"splitAt"
"sqrt"
"subtract"
"succ"
"sum"
"tail"
"take"
"takeWhile"
"tan"
"tanh"
"toEnum"
"toInteger"
"toRational"
"traverse"
"truncate"
"uncurry"
"undefined"
"unlines"
"until"
"unwords"
"unzip"
"unzip3"
"userError"
"words"
"writeFile"
"zip"
"zip3"
"zipWith"
"zipWith3"
"||"
 

<interactive>:225:1: error:
    • Couldn't match expected type ‘(Integer -> Integer -> Integer)
                                    -> t’
                  with actual type ‘[Char]’
    • The function ‘"Prelude.*"’ is applied to one argument,
      but its type ‘[Char]’ has none
      In the expression: "Prelude.*" div
      In an equation for ‘it’: it = "Prelude.*" div
    • Relevant bindings include it :: t (bound at <interactive>:225:1)
 "Prelude.**"
 "Prelude.*>"
 "Prelude.+"
 "Prelude.++"
 "Prelude.-"
 "Prelude.."
 "Prelude./"
 "Prelude./="
 "Prelude.<"
 "Prelude.<$"
 "Prelude.<$>"
 "Prelude.<*"
 "Prelude.<*>"
 "Prelude.<="
 "Prelude.<>"
 "Prelude.=<<"
 "Prelude.=="
 "Prelude.>"
 "Prelude.>="
 "Prelude.>>"
 "Prelude.>>="
 "Prelude.Applicative"
 "Prelude.Bool"
 "Prelude.Bounded"
 "Prelude.Char"
 "Prelude.Double"
 "Prelude.EQ"
 "Prelude.Either"
 "Prelude.Enum"
 "Prelude.Eq"
 "Prelude.False"
 "Prelude.FilePath"
 "Prelude.Float"
 "Prelude.Floating"
 "Prelude.Foldable"
 "Prelude.Fractional"
 "Prelude.Functor"
 "Prelude.GT"
 "Prelude.IO"
 "Prelude.IOError"
 "Prelude.Int"
 "Prelude.Integer"
 "Prelude.Integral"
 "Prelude.Just"
 "Prelude.LT"
 "Prelude.Left"
 "Prelude.Maybe"
 "Prelude.Monad"
 "Prelude.MonadFail"
 "Prelude.Monoid"
 "Prelude.Nothing"
 "Prelude.Num"
 "Prelude.Ord"
 "Prelude.Ordering"
 "Prelude.Rational"
 "Prelude.Read"
 "Prelude.ReadS"
 "Prelude.Real"
 "Prelude.RealFloat"
 "Prelude.RealFrac"
 "Prelude.Right"
 "Prelude.Semigroup"
 "Prelude.Show"
 "Prelude.ShowS"
 "Prelude.String"
 "Prelude.Traversable"
 "Prelude.True"
 "Prelude.Word"
 "Prelude.^"
 "Prelude.^^"
 "Prelude.abs"
 "Prelude.acos"
 "Prelude.acosh"
 "Prelude.all"
 "Prelude.and"
 "Prelude.any"
 "Prelude.appendFile"
 "Prelude.asTypeOf"
 "Prelude.asin"
 "Prelude.asinh"
 "Prelude.atan"
 "Prelude.atan2"
 "Prelude.atanh"
 "Prelude.break"
 "Prelude.ceiling"
 "Prelude.compare"
 "Prelude.concat"
 "Prelude.concatMap"
 "Prelude.const"
 "Prelude.cos"
 "Prelude.cosh"
 "Prelude.curry"
 "Prelude.cycle"
 "Prelude.decodeFloat"
 "Prelude.div"
 "Prelude.divMod"
 "Prelude.drop"
 "Prelude.dropWhile"
 "Prelude.either"
 "Prelude.elem"
 "Prelude.encodeFloat"
 "Prelude.enumFrom"
 "Prelude.enumFromThen"
 "Prelude.enumFromThenTo"
 "Prelude.enumFromTo"
 "Prelude.error"
 "Prelude.errorWithoutStackTrace"
 "Prelude.even"
 "Prelude.exp"
 "Prelude.exponent"
 "Prelude.fail"
 "Prelude.filter"
 "Prelude.flip"
 "Prelude.floatDigits"
 "Prelude.floatRadix"
 "Prelude.floatRange"
 "Prelude.floor"
 "Prelude.fmap"
 "Prelude.foldMap"
 "Prelude.foldl"
 "Prelude.foldl1"
 "Prelude.foldr"
 "Prelude.foldr1"
 "Prelude.fromEnum"
 "Prelude.fromInteger"
 "Prelude.fromIntegral"
 "Prelude.fromRational"
 "Prelude.fst"
 "Prelude.gcd"
 "Prelude.getChar"
 "Prelude.getContents"
 "Prelude.getLine"
 "Prelude.head"
 "Prelude.id"
 "Prelude.init"
 "Prelude.interact"
 "Prelude.ioError"
 "Prelude.isDenormalized"
 "Prelude.isIEEE"
 "Prelude.isInfinite"
 "Prelude.isNaN"
 "Prelude.isNegativeZero"
 "Prelude.iterate"
 "Prelude.last"
 "Prelude.lcm"
 "Prelude.length"
 "Prelude.lex"
 "Prelude.lines"
 "Prelude.log"
 "Prelude.logBase"
 "Prelude.lookup"
 "Prelude.map"
 "Prelude.mapM"
 "Prelude.mapM_"
 "Prelude.mappend"
 "Prelude.max"
 "Prelude.maxBound"
 "Prelude.maximum"
 "Prelude.maybe"
 "Prelude.mconcat"
 "Prelude.mempty"
 "Prelude.min"
 "Prelude.minBound"
 "Prelude.minimum"
 "Prelude.mod"
 "Prelude.negate"
 "Prelude.not"
 "Prelude.notElem"
 "Prelude.null"
 "Prelude.odd"
 "Prelude.or"
 "Prelude.otherwise"
 "Prelude.pi"
 "Prelude.pred"
 "Prelude.print"
 "Prelude.product"
 "Prelude.properFraction"
 "Prelude.pure"
 "Prelude.putChar"
 "Prelude.putStr"
 "Prelude.putStrLn"
 "Prelude.quot"
 "Prelude.quotRem"
 "Prelude.read"
 "Prelude.readFile"
 "Prelude.readIO"
 "Prelude.readList"
 "Prelude.readLn"
 "Prelude.readParen"
 "Prelude.reads"
 "Prelude.readsPrec"
 "Prelude.realToFrac"
 "Prelude.recip"
 "Prelude.rem"
 "Prelude.repeat"
 "Prelude.replicate"
 "Prelude.return"
 "Prelude.reverse"
 "Prelude.round"
 "Prelude.scaleFloat"
 "Prelude.scanl"
 "Prelude.scanl1"
 "Prelude.scanr"
 "Prelude.scanr1"
 "Prelude.seq"
 "Prelude.sequence"
 "Prelude.sequenceA"
 "Prelude.sequence_"
 "Prelude.show"
 "Prelude.showChar"
 "Prelude.showList"
 "Prelude.showParen"
 "Prelude.showString"
 "Prelude.shows"
 "Prelude.showsPrec"
 "Prelude.significand"
 "Prelude.signum"
 "Prelude.sin"
 "Prelude.sinh"
 "Prelude.snd"
 "Prelude.span"
 "Prelude.splitAt"
 "Prelude.sqrt"
 "Prelude.subtract"
 "Prelude.succ"
 "Prelude.sum"
 "Prelude.tail"
 "Prelude.take"
 "Prelude.takeWhile"
 "Prelude.tan"
 "Prelude.tanh"
 "Prelude.toEnum"
 "Prelude.toInteger"
 "Prelude.toRational"
 "Prelude.traverse"
 "Prelude.truncate"
 "Prelude.uncurry"
 "Prelude.undefined"
 "Prelude.unlines"
 "Prelude.until"
 "Prelude.unwords"
 "Prelude.unzip"
 "Prelude.unzip3"
 "Prelude.userError"
 "Prelude.words"
 "Prelude.writeFile"
 "Prelude.zip"
 "Prelude.zip3"
 "Prelude.zipWith"
 "Prelude.zipWith3"
 "Prelude.||"
 "Rational"
 "Read"
 "ReadS"
 "Real"
 "RealFloat"
 "RealFrac"
 "Right"
 "Semigroup"
 "Show"
 "ShowS"
 "String"
 "Traversable"
 "True"
 "Word"
 "^"
 "^^"
 "abs"
 "acos"
 "acosh"
 "all"
 "and"
 "any"
 "appendFile"
 "asTypeOf"
 "asin"
 "asinh"
 "atan"
 "atan2"
 "atanh"
 "break"
 "ceiling"
 "compare"
 "concat"
 "concatMap"
 "const"
 "cos"
 "cosh"
 "curry"
 "cycle"
 "decodeFloat"
 "div"
 "divMod"
 "drop"
 "dropWhile"
 "either"
 "elem"
 "encodeFloat"
 "enumFrom"
 "enumFromThen"
 "enumFromThenTo"
 "enumFromTo"
 "error"
 "errorWithoutStackTrace"
 "even"
 "exp"
 "exponent"
 "fail"
 "filter"
 "flip"
 "floatDigits"
 "floatRadix"
 "floatRange"
 "floor"
 "fmap"
 "foldMap"
 "foldl"
 "foldl1"
 "foldr"
 "foldr1"
 "fromEnum"
 "fromInteger"
 "fromIntegral"
 "fromRational"
 "fst"
 "gcd"
 "getChar"
 "getContents"
 "getLine"
 "head"
 "id"
 "init"
 "interact"
 "ioError"
 "isDenormalized"
 "isIEEE"
 "isInfinite"
 "isNaN"
 "isNegativeZero"
 "iterate"
 "last"
 "lcm"
 "length"
 "lex"
 "lines"
 "log"
 "logBase"
 "lookup"
 "map"
 "mapM"
 "mapM_"
 "mappend"
 "max"
 "maxBound"
 "maximum"
 "maybe"
 "mconcat"
 "mempty"
 "min"
 "minBound"
 "minimum"
 "mod"
 "negate"
 "not"
 "notElem"
 "null"
 "odd"
 "or"
 "otherwise"
 "pi"
 "pred"
 "print"
 "product"
 "properFraction"
 "pure"
 "putChar"
 "putStr"
 "putStrLn"
 "quot"
 "quotRem"
 "read"
 "readFile"
 "readIO"
 "readList"
 "readLn"
 "readParen"
 "reads"
 "readsPrec"
 "realToFrac"
 "recip"
 "rem"
 "repeat"
 "replicate"
 "return"
 "reverse"
 "round"
 "scaleFloat"
 "scanl"
 "scanl1"
 "scanr"
 "scanr1"
 "seq"
 "sequence"
 "sequenceA"
 "sequence_"
 "show"
 "showChar"
 "showList"
 "showParen"
 "showString"
 "shows"
 "showsPrec"
 "significand"
 "signum"
 "sin"
 "sinh"
 "snd"
 "span"
 "splitAt"
 "sqrt"
 "subtract"
 "succ"
 "sum"
 "tail"
 "take"
 "takeWhile"
 "tan"
 "tanh"
 "toEnum"
 "toInteger"
 "toRational"
 "traverse"
 "truncate"
 "uncurry"
 "undefined"
 "unlines"
 "until"
 "unwords"
 "unzip"
 "unzip3"
 "userError"
 "words"
 "writeFile"
 "zip"
 "zip3"
 "zipWith"
 "zipWith3"
 "||"
 Prelude| 

<interactive>:674:1: error: lexical error at character '\EOT'
 div 

<interactive>:681:1: error:
    • No instance for (Show (Integer -> Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 [minBound::Carta ..]
[੩A,੩2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 fmap (toEnum::Int->Carta) [1..52]
[੧A,੧2,੧3,੧4,੧5,੧6,੧7,੧8,੧9,੧10,੧J,੧Q,੧K,੪A,੪2,੪3,੪4,੪5,੪6,੪7,੪8,੪9,੪10,੪J,੪Q,੪K,੤A,੤2,੤3,੤4,੤5,੤6,੤7,੤8,੤9,੤10,੤J,੤Q,੤K,੩A,੩2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 abs(-1)
1
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 [minBound::Carta ..]
[੩A,੩2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 [minBound::Carta .. maxBound::Carta]
[੩A,੩2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 minBound::Carta
੩A
 toEnum

<interactive>:770:1: error:
    • No instance for (Show (Int -> a0)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
 (oEnum::Int->Carta) 1

<interactive>:789:2: error:
    • Variable not in scope: oEnum :: Int -> Carta
    • Perhaps you meant ‘toEnum’ (imported from Prelude)
 (toEnum::Int->Carta) 1
!"
"$"
"$!"
"&&"
"*"
"**"
"*>"
"+"
"++"
"-"
"."
"/"
"/="
"<"
"<$"
"<$>"
"<*"
"<*>"
"<="
"<>"
"=<<"
"=="
">"
">="
">>"
">>="
"Ace"
"Applicative"
"Bool"
"Bounded"
"Carta"
"Char"
"Corazones"
"Dealer"
"Diamantes"
"Double"
"EQ"
"Either"
"Enum"
"Eq"
"False"
"FilePath"
"Float"
"Floating"
"Foldable"
"Fractional"
"Functor"
"GT"
"Ghci1.it"
"Ghci2.it"
"Ghci3.it"
"IO"
"IOError"
"Int"
"Integer"
"Integral"
"Jack"
"Jugador"
"Just"
"King"
"LT"
"Left"
"Mano"
"Maybe"
"Monad"
"MonadFail"
"Monoid"
"N"
"Nothing"
"Num"
"Ord"
"Ordering"
"Palo"
"Picas"
"Player"
"Prelude.!!"
"Prelude.$"
"Prelude.$!"
"Prelude.&&"
"Prelude.*"
"Prelude.**"
"Prelude.*>"
"Prelude.+"
"Prelude.++"
"Prelude.-"
"Prelude.."
"Prelude./"
"Prelude./="
"Prelude.<"
"Prelude.<$"
"Prelude.<$>"
"Prelude.<*"
"Prelude.<*>"
"Prelude.<="
"Prelude.<>"
"Prelude.=<<"
"Prelude.=="
"Prelude.>"
"Prelude.>="
"Prelude.>>"
"Prelude.>>="
"Prelude.Applicative"
"Prelude.Bool"
"Prelude.Bounded"
"Prelude.Char"
"Prelude.Double"
"Prelude.EQ"
"Prelude.Either"
"Prelude.Enum"
"Prelude.Eq"
"Prelude.False"
"Prelude.FilePath"
"Prelude.Float"
"Prelude.Floating"
"Prelude.Foldable"
"Prelude.Fractional"
"Prelude.Functor"
"Prelude.GT"
"Prelude.IO"
"Prelude.IOError"
"Prelude.Int"
"Prelude.Integer"
"Prelude.Integral"
"Prelude.Just"
"Prelude.LT"
"Prelude.Left"
"Prelude.Maybe"
"Prelude.Monad"
"Prelude.MonadFail"
"Prelude.Monoid"
"Prelude.Nothing"
"Prelude.Num"
"Prelude.Ord"
"Prelude.Ordering"
"Prelude.Rational"
"Prelude.Read"
"Prelude.ReadS"
"Prelude.Real"
"Prelude.RealFloat"
"Prelude.RealFrac"
"Prelude.Right"
"Prelude.Semigroup"
"Prelude.Show"
"Prelude.ShowS"
"Prelude.String"
"Prelude.Traversable"
"Prelude.True"
"Prelude.Word"
"Prelude.^"
"Prelude.^^"
"Prelude.abs"
"Prelude.acos"
"Prelude.acosh"
"Prelude.all"
"Prelude.and"
"Prelude.any"
"Prelude.appendFile"
"Prelude.asTypeOf"
"Prelude.asin"
"Prelude.asinh"
"Prelude.atan"
"Prelude.atan2"
"Prelude.atanh"
"Prelude.break"
"Prelude.ceiling"
"Prelude.compare"
"Prelude.concat"
"Prelude.concatMap"
"Prelude.const"
"Prelude.cos"
"Prelude.cosh"
"Prelude.curry"
"Prelude.cycle"
"Prelude.decodeFloat"
"Prelude.div"
"Prelude.divMod"
"Prelude.drop"
"Prelude.dropWhile"
"Prelude.either"
"Prelude.elem"
"Prelude.encodeFloat"
"Prelude.enumFrom"
"Prelude.enumFromThen"
"Prelude.enumFromThenTo"
"Prelude.enumFromTo"
"Prelude.error"
"Prelude.errorWithoutStackTrace"
"Prelude.even"
"Prelude.exp"
"Prelude.exponent"
"Prelude.fail"
"Prelude.filter"
"Prelude.flip"
"Prelude.floatDigits"
"Prelude.floatRadix"
"Prelude.floatRange"
"Prelude.floor"
"Prelude.fmap"
"Prelude.foldMap"
"Prelude.foldl"
"Prelude.foldl1"
"Prelude.foldr"
"Prelude.foldr1"
"Prelude.fromEnum"
"Prelude.fromInteger"
"Prelude.fromIntegral"
"Prelude.fromRational"
"Prelude.fst"
"Prelude.gcd"
"Prelude.getChar"
"Prelude.getContents"
"Prelude.getLine"
"Prelude.head"
"Prelude.id"
"Prelude.init"
"Prelude.interact"
"Prelude.ioError"
"Prelude.isDenormalized"
"Prelude.isIEEE"
"Prelude.isInfinite"
"Prelude.isNaN"
"Prelude.isNegativeZero"
"Prelude.iterate"
"Prelude.last"
"Prelude.lcm"
"Prelude.length"
"Prelude.lex"
"Prelude.lines"
"Prelude.log"
"Prelude.logBase"
"Prelude.lookup"
"Prelude.map"
"Prelude.mapM"
"Prelude.mapM_"
"Prelude.mappend"
"Prelude.max"
"Prelude.maxBound"
"Prelude.maximum"
"Prelude.maybe"
"Prelude.mconcat"
"Prelude.mempty"
"Prelude.min"
"Prelude.minBound"
"Prelude.minimum"
"Prelude.mod"
"Prelude.negate"
"Prelude.not"
"Prelude.notElem"
"Prelude.null"
"Prelude.odd"
"Prelude.or"
"Prelude.otherwise"
"Prelude.pi"
"Prelude.pred"
"Prelude.print"
"Prelude.product"
"Prelude.properFraction"
"Prelude.pure"
"Prelude.putChar"
"Prelude.putStr"
"Prelude.putStrLn"
"Prelude.quot"
"Prelude.quotRem"
"Prelude.read"
"Prelude.readFile"
"Prelude.readIO"
"Prelude.readList"
"Prelude.readLn"
"Prelude.readParen"
"Prelude.reads"
"Prelude.readsPrec"
"Prelude.realToFrac"
"Prelude.recip"
"Prelude.rem"
"Prelude.repeat"
"Prelude.replicate"
"Prelude.return"
"Prelude.reverse"
"Prelude.round"
"Prelude.scaleFloat"
"Prelude.scanl"
"Prelude.scanl1"
"Prelude.scanr"
"Prelude.scanr1"
"Prelude.seq"
"Prelude.sequence"
"Prelude.sequenceA"
"Prelude.sequence_"
"Prelude.show"
"Prelude.showChar"
"Prelude.showList"
"Prelude.showParen"
"Prelude.showString"
"Prelude.shows"
"Prelude.showsPrec"
"Prelude.significand"
"Prelude.signum"
"Prelude.sin"
"Prelude.sinh"
"Prelude.snd"
"Prelude.span"
"Prelude.splitAt"
"Prelude.sqrt"
"Prelude.subtract"
"Prelude.succ"
"Prelude.sum"
"Prelude.tail"
"Prelude.take"
"Prelude.takeWhile"
"Prelude.tan"
"Prelude.tanh"
"Prelude.toEnum"
"Prelude.toInteger"
"Prelude.toRational"
"Prelude.traverse"
"Prelude.truncate"
"Prelude.uncurry"
"Prelude.undefined"
"Prelude.unlines"
"Prelude.until"
"Prelude.unwords"
"Prelude.unzip"
"Prelude.unzip3"
"Prelude.userError"
"Prelude.words"
"Prelude.writeFile"
"Prelude.zip"
"Prelude.zip3"
"Prelude.zipWith"
"Prelude.zipWith3"
"Prelude.||"
"Queen"
"Rango"
"Rational"
"Read"
"ReadS"
"Real"
"RealFloat"
"RealFrac"
"Right"
"Semigroup"
"Show"
"ShowS"
"String"
"Traversable"
"Treboles"
"True"
"Word"
"^"
"^^"
"abs"
"acos"
"acosh"
"all"
"and"
"any"
"appendFile"
"asTypeOf"
"asin"
"asinh"
"atan"
"atan2"
"atanh"
"baraja"
"break"
"ceiling"
"compare"
"concat"
"concatMap"
"const"
"cos"
"cosh"
"curry"
"cycle"
"decodeFloat"
"div"
"divMod"
"drop"
"dropWhile"
"either"
"elem"
"encodeFloat"
"enumFrom"
"enumFromThen"
"enumFromThenTo"
"enumFromTo"
"error"
"errorWithoutStackTrace"
"even"
"exp"
"exponent"
"fail"
"filter"
"flip"
"floatDigits"
"floatRadix"
"floatRange"
"floor"
"fmap"
"foldMap"
"foldl"
"foldl1"
"foldr"
"foldr1"
"fromEnum"
"fromInteger"
"fromIntegral"
"fromRational"
"fst"
"gcd"
"getChar"
"getContents"
"getLine"
"head"
"id"
"init"
"interact"
"ioError"
"isDenormalized"
"isIEEE"
"isInfinite"
"isNaN"
"isNegativeZero"
"it"
"iterate"
"last"
"lcm"
"length"
"lex"
"lines"
"log"
"logBase"
"lookup"
"map"
"mapM"
"mapM_"
"mappend"
"max"
"maxBound"
"maximum"
"maybe"
"mconcat"
"mempty"
"min"
"minBound"
"minimum"
"mod"
"negate"
"not"
"notElem"
"null"
"odd"
"or"
"otherwise"
"palo"
"pi"
"pred"
"print"
"product"
"properFraction"
"pure"
"putChar"
"putStr"
"putStrLn"
"quot"
"quotRem"
"rango"
"read"
"readFile"
"readIO"
"readList"
"readLn"
"readParen"
"reads"
"readsPrec"
"realToFrac"
"recip"
"rem"
"repeat"
"replicate"
"return"
"reverse"
"round"
"scaleFloat"
"scanl"
"scanl1"
"scanr"
"scanr1"
"seq"
"sequence"
"sequenceA"
"sequence_"
"show"
"showChar"
"showList"
"showParen"
"showString"
"shows"
"showsPrec"
"significand"
"signum"
"sin"
"sinh"
"snd"
"span"
"splitAt"
"sqrt"
"subtract"
"succ"
"sum"
"tail"
"take"
"takeWhile"
"tan"
"tanh"
"toEnum"
"toInteger"
"toRational"
"traverse"
"truncate"
"uncurry"
"undefined"
"unlines"
"until"
"unwords"
"unzip"
"unzip3"
"userError"
"vacia"
"words"
"writeFile"
"zip"
"zip3"
"zipWith"
"zipWith3"
"||"
  (toEnum::Int->Carta) 1
੧A
 minBound::Carta
੩A
  (toEnum::Int->Palo) 1
੪
 (1-1) `div` 13
0
 abs (1-1) `div` 13
0
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

  (toEnum::Int->Carta) 1 == minBound::Carta

<interactive>:852:2: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Bool’
    • In the expression:
          (toEnum :: Int -> Carta) 1 == minBound :: Carta
      In an equation for ‘it’:
          it = (toEnum :: Int -> Carta) 1 == minBound :: Carta
 ( (toEnum::Int->Carta) 1) == (minBound::Carta)
True
 [minBound::Carta ..]
[੧A,੧2,੧3,੧4,੧5,੧6,੧7,੧8,੧9,੧10,੧J,੧Q,੧K,੪A,੪2,੪3,੪4,੪5,੪6,੪7,੪8,੪9,੪10,੪J,੪Q,੪K,੤A,੤2,੤3,੤4,੤5,੤6,੤7,੤8,੤9,੤10,੤J,੤Q,੤K,੩A,੩2,੩3,੩4,੩5,੩6,੩7,੩8,੩9,੩10,੩J,੩Q,੩K]
 length
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 length [5..8]
4
 :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
 foldr (+) (1,2) 0

<interactive>:923:1: error:
    • Non type-variable argument in the constraint: Num (a, b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall (t :: * -> *) a b.
              (Foldable t, Num a, Num b, Num (t (a, b)), Num (a, b)) =>
              (a, b)
 foldr (+) 0 (1,2) 
2
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:34: error:
    • Couldn't match type ‘(Int, Int)’ with ‘Carta’
      Expected type: (Int, Int) -> (Int, Int) -> (Int, Int)
        Actual type: (Int, Int) -> Carta -> (Int, Int)
    • In the first argument of ‘foldr’, namely ‘f’
      In the second argument of ‘($)’, namely ‘foldr f xs (0, 0)’
      In the expression: switch $ foldr f xs (0, 0)
    |
128 | valor (Mano xs) = switch $ foldr f xs (0,0) where
    |                                  ^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:36: error:
    • Couldn't match expected type ‘(Int, Int)’
                  with actual type ‘[Carta]’
    • In the second argument of ‘foldr’, namely ‘xs’
      In the second argument of ‘($)’, namely ‘foldr f xs (0, 0)’
      In the expression: switch $ foldr f xs (0, 0)
    |
128 | valor (Mano xs) = switch $ foldr f xs (0,0) where
    |                                    ^^
Failed, no modules loaded.

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:34: error:
    • Couldn't match type ‘(Int, Int)’ with ‘Carta’
      Expected type: (Int, Int) -> (Int, Int) -> (Int, Int)
        Actual type: (Int, Int) -> Carta -> (Int, Int)
    • In the first argument of ‘foldr’, namely ‘f’
      In the second argument of ‘($)’, namely ‘foldr f xs (0, 0)’
      In the expression: switch $ foldr f xs (0, 0)
    |
128 | valor (Mano xs) = switch $ foldr f xs (0,0) where
    |                                  ^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:36: error:
    • Couldn't match expected type ‘(Int, Int)’
                  with actual type ‘[Carta]’
    • In the second argument of ‘foldr’, namely ‘xs’
      In the second argument of ‘($)’, namely ‘foldr f xs (0, 0)’
      In the expression: switch $ foldr f xs (0, 0)
    |
128 | valor (Mano xs) = switch $ foldr f xs (0,0) where
    |                                    ^^
Failed, no modules loaded.

 :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:34: error:
    • Couldn't match type ‘(Int, Int)’ with ‘Carta’
      Expected type: (Int, Int) -> (Int, Int) -> (Int, Int)
        Actual type: (Int, Int) -> Carta -> (Int, Int)
    • In the first argument of ‘foldr’, namely ‘f’
      In the second argument of ‘($)’, namely ‘foldr f (0, 0) xs’
      In the expression: switch $ foldr f (0, 0) xs
    |
128 | valor (Mano xs) = switch $ foldr f (0,0) xs  where
    |                                  ^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:42: error:
    • Couldn't match type ‘Carta’ with ‘(Int, Int)’
      Expected type: [(Int, Int)]
        Actual type: [Carta]
    • In the third argument of ‘foldr’, namely ‘xs’
      In the second argument of ‘($)’, namely ‘foldr f (0, 0) xs’
      In the expression: switch $ foldr f (0, 0) xs
    |
128 | valor (Mano xs) = switch $ foldr f (0,0) xs  where
    |                                          ^^
Failed, no modules loaded.

 :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:34: error:
    • Couldn't match type ‘(Int, Int)’ with ‘Carta’
      Expected type: (Int, Int) -> (Int, Int) -> (Int, Int)
        Actual type: (Int, Int) -> Carta -> (Int, Int)
    • In the first argument of ‘foldr’, namely ‘f’
      In the second argument of ‘($)’, namely ‘foldr f (0, 0) xs’
      In the expression: switch $ foldr f (0, 0) xs
    |
128 | valor (Mano xs) = switch $ foldr f (0,0) xs  where
    |                                  ^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:128:42: error:
    • Couldn't match type ‘Carta’ with ‘(Int, Int)’
      Expected type: [(Int, Int)]
        Actual type: [Carta]
    • In the third argument of ‘foldr’, namely ‘xs’
      In the second argument of ‘($)’, namely ‘foldr f (0, 0) xs’
      In the expression: switch $ foldr f (0, 0) xs
    |
128 | valor (Mano xs) = switch $ foldr f (0,0) xs  where
    |                                          ^^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:130:6: error:
    • Couldn't match expected type ‘(Int, Int)’
                  with actual type ‘Carta’
    • In the pattern: Carta valor _
      In an equation for ‘f’:
          f (Carta valor _) (as, acc)
            | fromEnum valor >= 10 = (as, acc + 10)
            | valor == Ace = (as + 1, acc + 10)
            | otherwise = (as, acc + fromEnum valor)
      In an equation for ‘valor’:
          valor (Mano xs)
            = switch $ foldr f (0, 0) xs
            where
                f :: (Int, Int) -> Carta -> (Int, Int)
                f (Carta valor _) (as, acc)
                  | fromEnum valor >= 10 = (as, acc + 10)
                  | valor == Ace = (as + 1, acc + 10)
                  | otherwise = (as, acc + fromEnum valor)
                switch :: (Int, Int) -> Int
                switch (as, acc) = if acc > 21 then acc - as * 10 + as else acc
    |
130 |   f (Carta valor _) (as,acc)  | fromEnum valor >=10 = (as,acc+10)
    |      ^^^^^^^^^^^^^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:130:21: error:
    • Couldn't match expected type ‘Carta’
                  with actual type ‘(Int, Int)’
    • In the pattern: (as, acc)
      In an equation for ‘f’:
          f (Carta valor _) (as, acc)
            | fromEnum valor >= 10 = (as, acc + 10)
            | valor == Ace = (as + 1, acc + 10)
            | otherwise = (as, acc + fromEnum valor)
      In an equation for ‘valor’:
          valor (Mano xs)
            = switch $ foldr f (0, 0) xs
            where
                f :: (Int, Int) -> Carta -> (Int, Int)
                f (Carta valor _) (as, acc)
                  | fromEnum valor >= 10 = (as, acc + 10)
                  | valor == Ace = (as + 1, acc + 10)
                  | otherwise = (as, acc + fromEnum valor)
                switch :: (Int, Int) -> Int
                switch (as, acc) = if acc > 21 then acc - as * 10 + as else acc
    |
130 |   f (Carta valor _) (as,acc)  | fromEnum valor >=10 = (as,acc+10)
    |                     ^^^^^^^^
Failed, no modules loaded.

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  
 
 
 

  
 


   

  
 

  
 

  



    
 
 
 
 
 
 
 
 
 
 

  
 
 
 

  
 
 

  
 
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 let f = fmap (toEnum::Int->Carta)
*DataTypes| f [1..5]

<interactive>:1077:1: error:
    Va(Int,Int) ->riable not in scope: f :: [Integer] -> t
 f [1..5]

<interactive>:1087:1: error:
    Variable not in scope: f :: [Integer] -> t
 let f = fmap (toEnum::Int->Carta)
*DataTypes| 
 f [1..5]
[੧A,੧2,੧3,੧4,੧5]
 valor $ f [1..5]

<interactive>:1099:9: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the second argument of ‘($)’, namely ‘f [1 .. 5]’
      In the expression: valor $ f [1 .. 5]
      In an equation for ‘it’: it = valor $ f [1 .. 5]
 valor $ Mano $ f [1..5]
15
 valor $ Mano $ f [1,1,10,11,12]
32
 (((>) 21) . valor) $ f [11]

<interactive>:1150:22: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the second argument of ‘($)’, namely ‘f [11]’
      In the expression: (((>) 21) . valor) $ f [11]
      In an equation for ‘it’: it = (((>) 21) . valor) $ f [11]
 (((>) 21) . valor) $ f [1]
(Int,Int) ->
<interactive>:1151:22: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the second argument of ‘($)’, namely ‘f [1]’
      In the expression: (((>) 21) . valor) $ f [1]
      In an equation for ‘it’: it = (((>) 21) . valor) $ f [1]
 let f = fmap (toEnum::Int->Carta)
*DataTypes| 
 (((>) 21) . valor) $ f [1]

<interactive>:1154:22: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the second argument of ‘($)’, namely ‘f [1]’
      In the expression: (((>) 21) . valor) $ f [1]
      In an equation for ‘it’: it = (((>) 21) . valor) $ f [1]
 (((>) 21) . valor) $ Mano $ f [1]
True
 :t splitAt 
splitAt :: Int -> [a] -> ([a], [a])
 splitAt 2 [0..3]
([0,1],[2,3])
 fmap head splitAt 2 [0..3]

<interactive>:1200:11: error:
    • Couldn't match type ‘[a0] -> ([a0], [a0])’
                     with ‘[[Integer] -> t]’
      Expected type: Int -> [[Integer] -> t]
        Actual type: Int -> [a0] -> ([a0], [a0])
    • Probable cause: ‘splitAt’ is applied to too few arguments
      In the second argument of ‘fmap’, namely ‘splitAt’
      In the expression: fmap head splitAt 2 [0 .. 3]
      In an equation for ‘it’: it = fmap head splitAt 2 [0 .. 3]
    • Relevant bindings include it :: t (bound at <interactive>:1200:1)
 :t head
head :: [a] -> a
 fmap head $ splitAt 2 [0..3]
([0,1],2)
 fmap (splitAt 1) $ splitAt 2 [0..3]
([0,1],([2],[3]))
 fmap (splitAt 1) $ splitAt 2 [1..4]
([1,2],([3],[4]))
 fmap (splitAt 1) $ splitAt 2 [1..5]
([1,2],([3],[4,5]))
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:21: error:
    • Couldn't match expected type ‘[Carta]
                                    -> [Carta] -> (Mano, Carta, Mano)’
                  with actual type ‘[Carta]’
    • The function ‘l’ is applied to two arguments,
      but its type ‘[Carta]’ has none
      In the expression: (l c r)
      In an equation for ‘separar’:
          separar (Mano m)
            = (l c r)
            where
                n = length m
                half = n `div` 2
                (l, (c, r)) = (splitAt 1) <$> (splitAt half m)
    |
150 | separar (Mano m) = (l c r) where
    |                     ^^^^^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:21: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the expression: l
      In the expression: (l, c, r)
      In an equation for ‘separar’:
          separar (Mano m)
            = (l, c, r)
            where
                n = length m
                half = n `div` 2
                (l, (c, r)) = (splitAt 1) <$> (splitAt half m)
    |
150 | separar (Mano m) = (l, c, r) where
    |                     ^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:24: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘[Carta]’
    • In the expression: c
      In the expression: (l, c, r)
      In an equation for ‘separar’:
          separar (Mano m)
            = (l, c, r)
            where
                n = length m
                half = n `div` 2
                (l, (c, r)) = (splitAt 1) <$> (splitAt half m)
    |
150 | separar (Mano m) = (l, c, r) where
    |                        ^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:27: error:
    • Couldn't match expected type ‘Mano’ with actual type ‘[Carta]’
    • In the expression: r
      In the expression: (l, c, r)
      In an equation for ‘separar’:
          separar (Mano m)
            = (l, c, r)
            where
                n = length m
                half = n `div` 2
                (l, (c, r)) = (splitAt 1) <$> (splitAt half m)
    |
150 | separar (Mano m) = (l, c, r) where
    |                           ^
Failed, no modules loaded.

 traverse [1]

<interactive>:1247:10: error:
    • Couldn't match expected type ‘a -> f b’
                  with actual type ‘[Integer]’
    • In the first argument of ‘traverse’, namely ‘[1]’
      In the expression: traverse [1]
      In an equation for ‘it’: it = traverse [1]
    • Relevant bindings include
        it :: t a -> f (t b) (bound at <interactive>:1247:1)
 :t traverse 
traverse
  :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
 :t foldr 
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
 :t foldMap 
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
 :t const
const :: a -> b -> a
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:29: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Rango’
    • In the expression: foldr const Jack c
      In the expression: (Mano l, foldr const Jack c, Mano r)
      In an equation for ‘separar’:
          separar (Mano m)
            = (Mano l, foldr const Jack c, Mano r)
            where
                n = length m
                half = n `div` 2
                (l, (c, r)) = (splitAt 1) <$> (splitAt half m)
    |
150 | separar (Mano m) = (Mano l, foldr const Jack c, Mano r) where
    |                             ^^^^^^^^^^^^^^^^^^

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:46: error:
    • Couldn't match type ‘Carta’ with ‘Rango’
      Expected type: [Rango]
        Actual type: [Carta]
    • In the third argument of ‘foldr’, namely ‘c’
      In the expression: foldr const Jack c
      In the expression: (Mano l, foldr const Jack c, Mano r)
    |
150 | separar (Mano m) = (Mano l, foldr const Jack c, Mano r) where
    |                                              ^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:41: error:
    • Found hole: _ :: Carta
    • In the second argument of ‘foldr’, namely ‘_’
      In the expression: foldr const _ c
      In the expression: (Mano l, foldr const _ c, Mano r)
    • Relevant bindings include
        l :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:153:23)
        c :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:153:26)
        r :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:153:28)
        half :: Int
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:152:22)
        n :: Int
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:151:22)
        m :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:15)
        (Some bindings suppressed; use -fmax-relevant-binds=N or -fno-max-relevant-binds)
      Valid hole fits include
        maxBound :: forall a. Bounded a => a
          with maxBound @Carta
          (imported from ‘Prelude’ at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:1:8-16
           (and originally defined in ‘GHC.Enum’))
        minBound :: forall a. Bounded a => a
          with minBound @Carta
          (imported from ‘Prelude’ at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:1:8-16
           (and originally defined in ‘GHC.Enum’))
    |
150 | separar (Mano m) = (Mano l, foldr const _  c, Mano r) where
    |                                         ^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:41: error:
    • Found hole: _ :: Carta
    • In the second argument of ‘foldr’, namely ‘_’
      In the expression: foldr const _ c
      In the expression: (Mano l, foldr const _ c, Mano r)
    • Relevant bindings include
        l :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:153:23)
        c :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:153:26)
        r :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:153:28)
        half :: Int
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:152:22)
        n :: Int
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:151:22)
        m :: [Carta]
          (bound at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:150:15)
        (Some bindings suppressed; use -fmax-relevant-binds=N or -fno-max-relevant-binds)
      Valid hole fits include
        maxBound :: forall a. Bounded a => a
          with maxBound @Carta
          (imported from ‘Prelude’ at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:1:8-16
           (and originally defined in ‘GHC.Enum’))
        minBound :: forall a. Bounded a => a
          with minBound @Carta
          (imported from ‘Prelude’ at /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:1:8-16
           (and originally defined in ‘GHC.Enum’))
    |
150 | separar (Mano m) = (Mano l, foldr const _  c, Mano r) where
    |                                         ^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 separar $ Mano $ (toEnum::Carta) [1..]

<interactive>:1336:18: error:
    • Couldn't match expected type ‘[Integer] -> [Carta]’
                  with actual type ‘Carta’
    • The function ‘toEnum :: Carta’ is applied to one argument,
      but its type ‘Carta’ has none
      In the second argument of ‘($)’, namely ‘(toEnum :: Carta) [1 .. ]’
      In the second argument of ‘($)’, namely
        ‘Mano $ (toEnum :: Carta) [1 .. ]’

<interactive>:1336:19: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Int -> a0’
    • Probable cause: ‘toEnum’ is applied to too few arguments
      In the expression: toEnum :: Carta
      In the second argument of ‘($)’, namely ‘(toEnum :: Carta) [1 .. ]’
      In the second argument of ‘($)’, namely
        ‘Mano $ (toEnum :: Carta) [1 .. ]’
 separar $ Mano $ (toEnum::Carta) [1..10]

<interactive>:1341:18: error:
    • Couldn't match expected type ‘[Integer] -> [Carta]’
                  with actual type ‘Carta’
    • The function ‘toEnum :: Carta’ is applied to one argument,
      but its type ‘Carta’ has none
      In the second argument of ‘($)’, namely
        ‘(toEnum :: Carta) [1 .. 10]’
      In the second argument of ‘($)’, namely
        ‘Mano $ (toEnum :: Carta) [1 .. 10]’

<interactive>:1341:19: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Int -> a0’
    • Probable cause: ‘toEnum’ is applied to too few arguments
      In the expression: toEnum :: Carta
      In the second argument of ‘($)’, namely
        ‘(toEnum :: Carta) [1 .. 10]’
      In the second argument of ‘($)’, namely
        ‘Mano $ (toEnum :: Carta) [1 .. 10]’
 separar $ Mano $ fmap (toEnum::Carta) [1..]

<interactive>:1347:24: error:
    • Couldn't match expected type ‘Carta’ with actual type ‘Int -> a0’
    • Probable cause: ‘toEnum’ is applied to too few arguments
      In the first argument of ‘fmap’, namely ‘(toEnum :: Carta)’
      In the second argument of ‘($)’, namely
        ‘fmap (toEnum :: Carta) [1 .. ]’
      In the second argument of ‘($)’, namely
        ‘Mano $ fmap (toEnum :: Carta) [1 .. ]’

<interactive>:1347:24: error:
    • Couldn't match expected type ‘Integer -> Carta’
                  with actual type ‘Carta’
    • In the first argument of ‘fmap’, namely ‘(toEnum :: Carta)’
      In the second argument of ‘($)’, namely
        ‘fmap (toEnum :: Carta) [1 .. ]’
      In the second argument of ‘($)’, namely
        ‘Mano $ fmap (toEnum :: Carta) [1 .. ]’
 separar $ Mano $ fmap (toEnum::Int -> Carta) [1..]

<interactive>:1355:1: error:
    • No instance for (Show Mano) arising from a use of ‘print’
    • In a stmt of an interactive GHCi command: print it
 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )

/home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs:114:30: error:
    parse error on input ‘deriving’
    |
114 | newtype Mano = Mano [Carta] (deriving Eq,Show)
    |                              ^^^^^^^^
Failed, no modules loaded.

 
[1 of 1] Compiling DataTypes        ( /home/daniel/Documents/Haskell_Aux/Lenguajes1/Proyecto1/src/DataTypes.hs, interpreted )
Ok, one module loaded.

 separar $ Mano $ fmap (toEnum::Int -> Carta) [1..]
(Mano 

